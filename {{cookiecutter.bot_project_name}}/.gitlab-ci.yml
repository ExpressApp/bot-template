# YAML objects named with dot is anchors, which are not recognized as jobs
.common_anchors:
  - &prod_env APP_ENV=prod
  - &prod_bot_url BOT_URL="${BOT_PROJECT_NAME}.${PROD_SERVER_HOST}"
  - &dev_env APP_ENV=dev
  - &dev_bot_url BOT_URL="${BOT_PROJECT_NAME}.${DEV_SERVER_HOST}"
  - &image_name CONTAINER_RELEASE_IMAGE="$CI_REGISTRY_IMAGE:${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG}"
  - &postgres
      POSTGRES_USER=${CONTAINER_NAME} &&
      POSTGRES_DB=${CONTAINER_NAME} &&
      POSTGRES_PASSWORD=$(openssl rand -hex 16) &&
      POSTGRES_HOST=${PROD_POSTGRES_HOST} &&
      POSTGRES_DSN=postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST/$POSTGRES_DB
  - &redis REDIS_DSN=redis://${PROD_REDIS_HOST}/1
  - &bot_project_name if [ -z ${BOT_PROJECT_NAME:-} ]; then BOT_PROJECT_NAME=${CI_PROJECT_PATH_SLUG#"$CI_PROJECT_NAMESPACE-"}; fi

.deploy: &deploy
  - echo "Use URL 'https://${BOT_URL}/' in your cts admin site"
  - echo "Using credentials ${BOT_CREDENTIALS}"
  - echo "Deploing Docker container ${CONTAINER_NAME}"
  - psql -c "create user \"${POSTGRES_USER}\"" postgres || true
  - psql -c "alter user \"${POSTGRES_USER}\" with password '${POSTGRES_PASSWORD}'" postgres
  - psql -c "create database \"${POSTGRES_DB}\" with owner \"${POSTGRES_USER}\"" postgres || true
  - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY
  - docker pull ${CONTAINER_RELEASE_IMAGE}
  - docker rm -f ${CONTAINER_NAME} || true
  - docker run
    -d
    --name ${CONTAINER_NAME}
    --restart always
    --label traefik.http.routers.${BOT_PROJECT_NAME}.rule="Host(\`${BOT_URL}\`)"
    --label traefik.enable=true
    --label traefik.http.services.${BOT_PROJECT_NAME}.loadbalancer.server.port="8000"
    --log-opt max-size=10m
    --log-opt max-file=5
    -e APP_ENV="${APP_ENV}"
    -e DB_CONNECTION="${POSTGRES_DSN}"
    -e REDIS_DSN="${REDIS_DSN}"
    -e BOT_CREDENTIALS="${BOT_CREDENTIALS}"
    $CONTAINER_RELEASE_IMAGE

.stop: &stop
  - docker rm -f ${CONTAINER_NAME} || true
  - psql -c "drop database \"${POSTGRES_DB}\"" postgres || true
  - psql -c "drop user \"${POSTGRES_USER}\"" postgres || true

.storages: &storages
  - *postgres
  - *redis

.deploy_dev_config: &deploy_dev_config
  stage: deploy
  tags:
    - bots-test
  dependencies:
    - build
  variables:
    GIT_STRATEGY: none
  only:
    - branches
  when: manual

.deploy_prod_config: &deploy_prod_config
  stage: deploy
  tags:
    - bots-prod
  environment:
    name: production
  variables:
    GIT_STRATEGY: none
  only:
    # Note the bots-prod worker requires branch to be protected
    - master
  when: manual

.stage_check_config: &stage_check_config
  cache:
    key: "$CI_JOB_NAME"
    paths:
      - .cache

.deploy_stop_config: &deploy_stop_config
  when: manual
  environment:
    name: test
    action: stop

# Jobs
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  POETRY_VIRTUALENVS_PATH: "$CI_PROJECT_DIR/.cache/venv"

default:
  tags:
    - docker

  image:
    name: python:3.9

  before_script:
    - echo -e "machine ${GIT_HOST}\nlogin gitlab-ci-token\npassword ${CI_JOB_TOKEN}" > ~/.netrc
    - pip install poetry
    - poetry install
    - set -u

stages:
  - check
  - build
  - deploy

lint:
  <<: *stage_check_config
  stage: check
  script:
    - poetry run ./scripts/lint
    - cat ./scripts/so_pythonic.txt

test:
  <<: *stage_check_config
  stage: check
  services:
    - postgres:11.4-alpine
    - redis:6.0.1-alpine
  script:
    - poetry run pytest --cov-config=setup.cfg
  variables:
    TEST_DB_CONNECTION: postgres://postgres:postgres@postgres/postgres
    REDIS_DSN: redis://redis/0
    APP_ENV: test
  coverage: '/Total coverage: \d\d\d.\d\d%/'

build:
  image: docker:latest
  stage: build
  before_script:
    - docker info
    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY
    - CONTAINER_RELEASE_IMAGE="$CI_REGISTRY_IMAGE:${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG}"
  script:
    - docker build
      --build-arg GIT_HOST=$GIT_HOST
      --build-arg CI_JOB_TOKEN=$CI_JOB_TOKEN
      --build-arg CI_COMMIT_SHA=$CI_COMMIT_SHA
      --force-rm
      -t $CONTAINER_RELEASE_IMAGE .
    - docker push $CONTAINER_RELEASE_IMAGE
    - docker rmi $CONTAINER_RELEASE_IMAGE

deploy.sandbox:
  <<: *deploy_dev_config
  environment:
    name: test
    on_stop: deploy.sandbox.stop
  before_script:
    - *dev_env
    - GITLAB_USER_LOGIN="${GITLAB_USER_LOGIN/./_}"
    - BOT_PROJECT_NAME="$GITLAB_USER_LOGIN"
    - CONTAINER_NAME="$CI_PROJECT_PATH_SLUG-$GITLAB_USER_LOGIN"
    - BOT_CREDENTIALS="$GITLAB_USER_LOGIN"_BOT_CREDENTIALS
    - *dev_bot_url
    - *image_name
    - *storages
  script: *deploy

deploy.sandbox.stop:
  <<: *deploy_stop_config
  extends: deploy.sandbox
  script: *stop

deploy.test:
  <<: *deploy_dev_config
  environment:
    name: test
    on_stop: deploy.test.stop
  before_script:
    - *dev_env
    - *bot_project_name
    - CONTAINER_NAME=$BOT_PROJECT_NAME-`echo $CI_COMMIT_REF_NAME | sed 's/^.*\///'`
    - BOT_CREDENTIALS=$DEV_BOT_CREDENTIALS
    - *dev_bot_url
    - *image_name
    - *storages
  script: *deploy

deploy.test.stop:
  <<: *deploy_stop_config
  extends: deploy.test
  script: *stop

deploy.prod:
  <<: *deploy_prod_config
  before_script:
    - *prod_env
    - *bot_project_name
    - CONTAINER_NAME=$BOT_PROJECT_NAME
    - *prod_bot_url
    - *image_name
    - *storages
  script: *deploy
